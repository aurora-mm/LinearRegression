#' linreg function
#'
#' Fits a linear regression model using QR decomposition.
#'
#' @param formula A formula object describing the model to be fitted.
#' @param data A data frame containing the variables in the model.
#' @return An object of class linreg containing the fitted model.
#' @export
linreg <- function(formula, data) {
# Validate the input
if(!inherits(formula, "formula")) {
stop("The formula argument must be a formula object.")
}
if(!is.data.frame(data)) {
stop("The data argument must be a data frame.")
}
# Create design matrix X and response vector y
X <- model.matrix(formula, data)
y <- data[[all.vars(formula)[1]]]
# QR decomposition of X
qr_dec <- qr(X)
Q <- qr.Q(qr_dec)
R <- qr.R(qr_dec)
# Calculate beta coefficients
beta <- solve(R, t(Q) %*% y)
names(beta) <- colnames(X)  # Assign names to coefficients
# Calculate fitted values and residuals
y_hat <- X %*% beta
resid <- y - y_hat
# Variance of residuals (sigma^2)
n <- nrow(X)
p <- ncol(X)
sigma2 <- sum(resid^2) / (n - p)
# Variance of beta coefficients
var_beta <- sigma2 * solve(t(X) %*% X)
# Return a list as an S3 object of class linreg
return(structure(list(
coefficients = beta,
residuals = resid,
fitted_values = y_hat,
formula = formula,
data = data,
name = deparse(substitute(data)),
sigma2 = sigma2,
var_beta = var_beta,
df_residual = n - p
), class = "linreg"))
}
#' Print method for linreg class
#' @param x An object of class linreg.
#' @export
print.linreg <- function(x, ...) {
cat(paste0("linreg(formula = ",deparse(x$formula), ", data = ", x$name, ")"))
cat("\n\nCoefficients:\n")
cat(names(x$coefficients))
cat(paste0("\n",t(x$coefficients)))
}
#' Plot method for linreg class
#' @param x An object of class linreg.
#' @export
plot.linreg <- function(x, ...) {
data <- x$data
y_hat <- x$fitted_values
residuals <- x$residuals
# Standardized residuals
std_residuals <- residuals / sqrt(abs(x$sigma2))
# Create data frame for plotting
plot_data <- data.frame(
Fitted = y_hat,
Residuals = residuals,
Std_Residuals = std_residuals
)
# Residuals vs Fitted values
p1 <- ggplot(plot_data, aes(x = Fitted, y = Residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed") +
stat_summary(fun = median, color = "red", geom = "line", group = 1) +
labs(title = "Residuals vs Fitted",
x = paste0("Fitted values\n", "linreg(", deparse(x$formula), ")"), y = "Residuals") +
theme_minimal()
# Standardized Residuals vs Fitted values
p2 <- ggplot(plot_data, aes(x = Fitted, y = Std_Residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed") +
stat_summary(fun = median, color = "red", geom = "line", group = 1) +
labs(title = "Scale-Location",
x = paste0("Fitted values\n", "linreg(", deparse(x$formula), ")"), y = "Standardized residuals") +
theme_minimal()
# Plot both graphs
print(p1)
print(p2)
}
#' Residuals method for linreg class
#' @param object An object of class linreg.
#' @export
resid.linreg <- function(object, ...) {
return(object$residuals)
}
#' Predicted values method for linreg class
#' @param object An object of class linreg.
#' @export
pred.linreg <- function(object, ...) {
return(object$fitted_values)
}
#' Coefficients method for linreg class
#' @param object An object of class linreg.
#' @export
coef.linreg <- function(object, ...) {
return(object$coefficients)
}
#' Summary method for linreg class
#' @param object An object of class linreg.
#' @export
summary.linreg <- function(object, ...) {
# Calculate t-values, p-values, and standard errors
std_errors <- sqrt(diag(object$var_beta))
t_values <- object$coefficients / std_errors
p_values <- 2 * pt(-abs(t_values), df = object$df_residual)
# Create a summary table
summary_table <- data.frame(
Estimate = object$coefficients,
`Std. Error` = std_errors,
`t value` = t_values
)
print.data.frame(round(summary_table, digits = 2))
cat("\nResidual standard error:", round(sqrt(object$sigma2), digits = 2), "on", object$df_residual, "degrees of freedom\n")
}
package.skeleton(name = "LinearRegression")
#' linreg function
#'
#' Fits a linear regression model using QR decomposition.
#'
#' @param formula A formula object describing the model to be fitted.
#' @param data A data frame containing the variables in the model.
#' @return An object of class linreg containing the fitted model.
#' @export
linreg <- function(formula, data) {
# Validate the input
if(!inherits(formula, "formula")) {
stop("The formula argument must be a formula object.")
}
if(!is.data.frame(data)) {
stop("The data argument must be a data frame.")
}
# Create design matrix X and response vector y
X <- model.matrix(formula, data)
y <- data[[all.vars(formula)[1]]]
# QR decomposition of X
qr_dec <- qr(X)
Q <- qr.Q(qr_dec)
R <- qr.R(qr_dec)
# Calculate beta coefficients
beta <- solve(R, t(Q) %*% y)
names(beta) <- colnames(X)  # Assign names to coefficients
# Calculate fitted values and residuals
y_hat <- X %*% beta
resid <- y - y_hat
# Variance of residuals (sigma^2)
n <- nrow(X)
p <- ncol(X)
sigma2 <- sum(resid^2) / (n - p)
# Variance of beta coefficients
var_beta <- sigma2 * solve(t(X) %*% X)
# Return a list as an S3 object of class linreg
return(structure(list(
coefficients = beta,
residuals = resid,
fitted_values = y_hat,
formula = formula,
data = data,
name = deparse(substitute(data)),
sigma2 = sigma2,
var_beta = var_beta,
df_residual = n - p
), class = "linreg"))
}
#' Print method for linreg class
#' @param x An object of class linreg.
#' @export
print.linreg <- function(x, ...) {
cat(paste0("linreg(formula = ",deparse(x$formula), ", data = ", x$name, ")"))
cat("\n\nCoefficients:\n")
cat(names(x$coefficients))
cat(paste0("\n",t(x$coefficients)))
}
#' Plot method for linreg class
#' @param x An object of class linreg.
#' @export
plot.linreg <- function(x, ...) {
data <- x$data
y_hat <- x$fitted_values
residuals <- x$residuals
# Standardized residuals
std_residuals <- residuals / sqrt(abs(x$sigma2))
# Create data frame for plotting
plot_data <- data.frame(
Fitted = y_hat,
Residuals = residuals,
Std_Residuals = std_residuals
)
# Residuals vs Fitted values
p1 <- ggplot2::ggplot(plot_data, aes(x = Fitted, y = Residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed") +
stat_summary(fun = median, color = "red", geom = "line", group = 1) +
labs(title = "Residuals vs Fitted",
x = paste0("Fitted values\n", "linreg(", deparse(x$formula), ")"), y = "Residuals") +
theme_minimal()
# Standardized Residuals vs Fitted values
p2 <- ggplot2::ggplot(plot_data, aes(x = Fitted, y = Std_Residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed") +
stat_summary(fun = median, color = "red", geom = "line", group = 1) +
labs(title = "Scale-Location",
x = paste0("Fitted values\n", "linreg(", deparse(x$formula), ")"), y = "Standardized residuals") +
theme_minimal()
# Plot both graphs
print(p1)
print(p2)
}
#' Residuals method for linreg class
#' @param object An object of class linreg.
#' @export
resid.linreg <- function(object, ...) {
return(object$residuals)
}
#' Predicted values method for linreg class
#' @param object An object of class linreg.
#' @export
pred.linreg <- function(object, ...) {
return(object$fitted_values)
}
#' Coefficients method for linreg class
#' @param object An object of class linreg.
#' @export
coef.linreg <- function(object, ...) {
return(object$coefficients)
}
#' Summary method for linreg class
#' @param object An object of class linreg.
#' @export
summary.linreg <- function(object, ...) {
# Calculate t-values, p-values, and standard errors
std_errors <- sqrt(diag(object$var_beta))
t_values <- object$coefficients / std_errors
p_values <- 2 * pt(-abs(t_values), df = object$df_residual)
# Create a summary table
summary_table <- data.frame(
Estimate = object$coefficients,
`Std. Error` = std_errors,
`t value` = t_values
)
print.data.frame(round(summary_table, digits = 2))
cat("\nResidual standard error:", round(sqrt(object$sigma2), digits = 2), "on", object$df_residual, "degrees of freedom\n")
}
devtools::load_all(".")
warnings()
devtools::load_all(".")
devtools::load_all(".")
devtools::uses_testthat()
usethis::use_testthat()
linreg_mod <- linreg(Petal.Length~Sepal.Width+Sepal.Length, data=iris)
round(unname(pred(linreg_mod)[c(1,5,7)]),2)
(pred(linreg_mod)
)
pred(linreg_mod)
devtools::load_all(".")
pred.linreg()
?pred
pred(sss)
getAnywhere(pred)
getAnywhere(linreg)
LinearRegression::pred.linreg()
.S3method(pred, linreg())
.S3method(pred, linreg
)
.S3method(pred, linreg)
devtools::load_all(".")
devtools::load_all(".")
resid.linreg()
pred.linreg()
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
?pred.linreg
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
coef(linreg_mod)
devtools::load_all(".")
resid(linreg_mod)
vector(linreg_mod$residuals)
as.vector(linreg_mod$residuals)
devtools::load_all(".")
devtools::load_all(".")
#' Predicted values method for linreg class
#' @param object An object of class linreg.
#' @export
pred.linreg <- function(object, ...) {
return(as.vector(object$fitted_values))
}
devtools::load_all(".")
rm(list = c("pred.linreg"))
devtools::load_all(".")
pred
pred.linreg
resid.linreg
resid
library(rpart)
devtools::load_all(".")
S3method
devtools::load_all(".")
summary(linreg_mod)
summary.linreg(linreg_mod)
std_errors <- sqrt(diag(linreg_mod$var_beta))
t_values <- linreg_mod$coefficients / std_errors
p_values <- 2 * pt(-abs(t_values), df = linreg_mod$df_residual)
linreg_mod$coefficients
names(linreg_mod$coefficients)
cbind(names(linreg_mod$coefficients), as.vector(linreg_mod$coefficients))
devtools::load_all(".")
sumamry(linreg_mod)
summary(linreg_mod)
summary.linreg(linreg_mod)
# Calculate t-values, p-values, and standard errors
std_errors <- sqrt(diag(object$var_beta))
t_values <- object$coefficients / std_errors
# Create a summary table
sum_t <- as.data.frame(cbind(names(linreg_mod$coefficients),
as.vector(linreg_mod$coefficients),
as.vector(std_errors),
as.vector(t_values),
as.vector(p_values)))
cat(sum_t)
cat(sum_t[1,])
cat(paste(sum_t))
print(sum_t)
summary.default(linreg_mod)
sum_t
devtools::load_all(".")
devtools::load_all(".")
summary(linreg_mod)
summary.linreg(linreg_mod)
object <- linreg_mod
# Calculate standard errors, t-values, and p-values
se <- sqrt(diag(object$var_beta))
t_values <- object$coefficients / se
p_values <- 2 * pt(-abs(t_values), df = object$df_residual)
# Coefficients table
coef_table <- data.frame(
Estimate = object$coefficients,
`Std. Error` = se,
`t value` = t_values,
`Pr(>|t|)` = p_values
)
View(coef_table)
print(coef_table)
# Coefficients table
coef_table <- data.frame(
Estimate = object$coefficients,
SE = se,
t = t_values,
P = p_values
)
View(coef_table)
print(coef_table)
print(round(coef_table), digits = 2)
print(round(coef_table, digits = 2))
print(round(coef_table, digits = 3))
cat("\nResidual standard error:", sqrt(object$sigma2), "on", object$df, "degrees of freedom\n")
devtools::load_all(".")
expect_output("Sepal.Length 1.776 0.064  27.569 0", "Sepal.Length( )*1.7[0-9]*( )*0.0[0-9]*( )*27.5[0-9]*( )*.*( )*\\*\\*\\*")
expect_output("Sepal.Length 1.776 0.064  27.569 0", "Sepal.Length( )*1.7[0-9]*( )*0.0[0-9]*( )*27.5[0-9]*( )*.*( )*\\*\\*\\*")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
usethis::use_package("ggplot2")
devtools::load_all(".")
?resid
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
print(linreg_mod)
devtools::load_all(".")
print(linreg_mod)
devtools::load_all(".")
print(linreg_mod)
devtools::load_all(".")
print(linreg_mod)
linreg_mod$coefficients
round(linreg_mod$coefficients)
round(t(linreg_mod$coefficients))
devtools::load_all(".")
devtools::load_all(".")
usethis::use_github_action_check_standard()
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
x <- object
# Calculate standard errors, t-values, and p-values
se <- sqrt(diag(x$var_beta))
t_values <- x$coefficients / se
p_values <- 2 * pt(-abs(t_values), df = x$df_residual)
# Function for showing asterisks
fixstars <- function(p_values) {
if (p_values > 0.1) return(" ")
if (p_values > 0.05) return(".")
if (p_values > 0.01) return("*")
if (p_values > 0.001) return("**")
return("***")
}
# Coefficients table
coef_table <- data.frame(
Estimate = x$coefficients,
SE = se,
t = t_values,
P = p_values,
star = fixstars(p_values)
)
starz <- fixstars(p_values)
View(p_values)
p_values <- round(2 * pt(-abs(t_values), df = x$df_residual), digits = 4)
p_values <- round(2 * pt(-abs(t_values), df = x$df_residual), digits = 4)
# Function for showing asterisks
fixstars <- function(p_values) {
if(p_values < 0.001) return("***")
}
starz <- fixstars(p_values)
# Function for showing asterisks
fixstars <- function(p_values) {
return("***")
}
starz <- fixstars(p_values)
# Coefficients table
coef_table <- data.frame(
Estimate = x$coefficients,
SE = se,
t = t_values,
P = p_values,
star = fixstars(p_values)
)
# Function for showing asterisks
fixstars <- function(p_values) {
return("***")
}
starz <- fixstars(p_values)
# Coefficients table
coef_table <- data.frame(
Estimate = x$coefficients,
SE = se,
t = t_values,
P = p_values,
star = starz
)
print(coef_table)
devtools::load_all(".")
linreg_mod <- linreg(Petal.Length~Sepal.Width+Sepal.Length, data=iris)
x <- linreg_mod
# Calculate standard errors, t-values, and p-values
se <- sqrt(diag(x$var_beta))
t_values <- x$coefficients / se
p_values <- 2 * pt(-abs(t_values), df = x$df_residual)
p_values > 0.01
nrow(p_values)
seq_along(p_values)
# Calculate standard errors, t-values, and p-values
se <- sqrt(diag(x$var_beta))
t_values <- x$coefficients / se
p_values <- 2 * pt(-abs(t_values), df = x$df_residual)
# Function for showing asterisks
fixstars <- function(p_values) {
for(i in seq_along(p_values)) {
if(p_values[i] > 0.1) return(" ")
if(p_values[i] > 0.05) return(".")
if(p_values[i] > 0.01) return("*")
if(p_values[i] > 0.001) return("**")
}
return("***")
}
starz <- fixstars(p_values)
# Coefficients table
coef_table <- data.frame(
Estimate = x$coefficients,
SE = se,
t = t_values,
P = p_values,
star = starz
)
View(coef_table)
print(coef_table)
devtools::load_all(".")
devtools::load_all(".")
plot(linreg_mod)
summary(linreg_mod)
devtools::load_all(".")
linreg_mod <- linreg(Petal.Length~Species, data=iris)
plot(linreg_mod)
